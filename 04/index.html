<html>
  <head>
    <title> Fleeing Fish </title>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <title>Default WebGL!</title>
    <style>
      html, body { 
        background: url('https://cs460.org/assignments/04/bg.jpg');
        background-size: cover;
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden !important;  
      }

      #c {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <script type="text/javascript" src="https://cs460.org/js/glmatrix.js"></script>
  
  <script id="vertexshader" type="glsl">
    attribute vec3 a_position;

    uniform float u_pointsize;

    uniform mat4 u_transform;

    void main(void) {

      vec4 final_position = u_transform * vec4(a_position, 1.);

      gl_Position = final_position;

      gl_PointSize = u_pointsize;
    
    }
  </script>
  
<!-- removed from line 35:
      vec3 final_position = a_position;
      final_position.x += u_offset.x;
      final_position.y += u_offset.y;
      final_position.z += u_offset.z;
    
      gl_Position = vec4( final_position, 1.); -->

  <script id="fragmentshader" type="glsl">
    precision mediump float;

    uniform vec4 u_color;

    void main(void) {

      gl_FragColor = u_color;

    }
  </script>
  
  <script>

    var c, gl;
    var v_shader, f_shader, shaderprogram;
    var vertices, indices, v_buffer, i_buffer;
    var all_fish;
    var mouse_x_pos = 0;
    var mouse_y_pos = 0;

    window.onload = function() {

      //************************************************************//
      //
      // INITIALIZE WEBGL
      //
      c = document.getElementById( 'c' ); // setup canvas
      c.width = window.innerWidth;
      c.height = window.innerHeight;

      gl = c.getContext( 'webgl' ); // setup GL context
      gl.viewport(0, 0, c.width, c.height );


      //************************************************************//
      //
      // SHADERS
      //
      v_shader = gl.createShader( gl.VERTEX_SHADER );
      f_shader = gl.createShader( gl.FRAGMENT_SHADER );
      
      // compile vertex shader
      gl.shaderSource( v_shader, document.getElementById( 'vertexshader' ).innerText );
      gl.compileShader( v_shader );

      if (!gl.getShaderParameter( v_shader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog( v_shader ));
      }

      // compile fragment shader
      gl.shaderSource( f_shader, document.getElementById( 'fragmentshader' ).innerText );
      gl.compileShader( f_shader );

      if (!gl.getShaderParameter( f_shader, gl.COMPILE_STATUS)) {
        console.log(gl.getShaderInfoLog( f_shader ));
      }

      // attach and link the shaders
      shaderprogram = gl.createProgram();
      gl.attachShader( shaderprogram, v_shader );
      gl.attachShader( shaderprogram, f_shader );

      gl.linkProgram( shaderprogram );

      gl.useProgram( shaderprogram );


      // create fish
      all_fish = [];
      all_fish.push(createFish([0, 0, 0], [1.,0.,0.,1.], 1, -1));

      for (var i = 0; i < 100; i++) {
        random_color = [Math.random(), Math.random(), Math.random(), Math.random() * 0.75 + 0.25];

        random_offset = [Math.random() - Math.random(), Math.random() - Math.random(), Math.random() - Math.random()];

        random_scale = Math.random() * 0.2 + 0.1;

        fish = createFish(random_offset, 
        random_color, random_scale, 1);

        all_fish.push(fish);
      }

      window.alert("Move the mouse to control the fish!")

      animate();

    };

    window.onmousemove = function(e) {
      mouse_x_pos = (e.clientX / window.innerWidth) * 2 - 1;
      mouse_y_pos = -1 * (e.clientY / window.innerHeight) * 2 + 1;
      all_fish[0][3][0] = mouse_x_pos;
      all_fish[0][3][1] = mouse_y_pos;
    }

    function createFish(offset, color, scale, direction, flee_state = 0) {      
      var vertices = new Float32Array([
        0.5, 0.0, 0.0,    // 0: nose
        0.2, 0.25, 0.0,   // 1: upper body
        -0.2, 0.15, 0.0,  // 2: upper tail base
        -0.4, 0.3, 0.0,   // 3: upper tail tip
        -0.4, -0.3, 0.0,  // 4: lower tail tip
        -0.2, -0.15, 0.0, // 5: lower tail base
        0.2, -0.25, 0.0   // 6: lower body
      ])

      // now use indices
      var indices = new Uint8Array([ 
        0, 1, 6, // main body
        1, 2, 6, // upper mid-body
        2, 5, 6, // rear body
        2, 3, 5, // tail top
        3, 4, 5  // tail fin
      ]);

      if (direction == 1) {
        eye_vertex = new Float32Array([0.2, 0.2, 0.0]);
      }

      if (direction == -1) {
        eye_vertex = new Float32Array([0.2, -0.2, 0.0]);
      }

      eye_v_buffer = gl.createBuffer(); // creat
      gl.bindBuffer(gl.ARRAY_BUFFER, eye_v_buffer); // bind
      gl.bufferData(gl.ARRAY_BUFFER, eye_vertex, gl.STATIC_DRAW); // put data in
      gl.bindBuffer(gl.ARRAY_BUFFER, null); // unbind


      var v_buffer = gl.createBuffer(); // create
      gl.bindBuffer( gl.ARRAY_BUFFER, v_buffer ); // bind
      gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW ); // put data in
      gl.bindBuffer( gl.ARRAY_BUFFER, null ); // unbind

      var i_buffer = gl.createBuffer(); // create
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, i_buffer ); // bind
      gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW ); // put data in
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null ); // unbind

      return [v_buffer, i_buffer, eye_v_buffer, offset, color, scale, direction, flee_state];

    };

    function animate() {

      for (var i = 1; i < all_fish.length; i++) {

        fish_x_pos = all_fish[i][3][0];
        fish_y_pos = all_fish[i][3][1];

        x_difference = fish_x_pos - mouse_x_pos;
        y_difference = fish_y_pos - mouse_y_pos;

        all_fish[i][7] = 0;

        if (x_difference < 0 && x_difference > -0.6) {
          if (y_difference < 0 && y_difference > -0.4) {
            all_fish[i][3][0] -= 0.002;
            all_fish[i][3][1] -= 0.006;
            all_fish[i][7] = -1;
          }
          if (y_difference > 0 && y_difference < 0.4) {
            all_fish[i][3][0] -= 0.002;
            all_fish[i][3][1] += 0.006;
            all_fish[i][7] = 1;
          }
        }
        if (x_difference > 0 && x_difference < 0.6 && Math.abs(y_difference) < 0.1) {
          all_fish[i][3][0] += 0.01;
        }
      }

      requestAnimationFrame(animate);

      gl.clearColor( 0., 0., 0., 0.)
      gl.clear( gl.COLOR_BUFFER_BIT );

      gl.enable(gl.BLEND);
      gl.blendEquation(gl.FUNC_ADD);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

      gl.disable(gl.DEPTH_TEST);



      for( var r = 0; r < all_fish.length; r++ ) {

        // current_buffers is a list of [v_buffer, i_buffer]-pairs
        var current_buffers = all_fish[r];
        var current_v_buffer = current_buffers[0];
        var current_i_buffer = current_buffers[1];
        var current_eye_v_buffer = current_buffers[2]
        var current_offset = current_buffers[3];
        var current_color = current_buffers[4];
        var current_scale = current_buffers[5];
        var current_direction = current_buffers[6];
        var current_flee_state = current_buffers[7];

        current_offset[0] += 0.012 * Math.random() - 0.006 * Math.random();
        current_offset[1] += 0.03 * Math.random();
        current_offset[1] -= 0.03 * Math.random();

        if (current_offset[0] >= 1) {
          current_offset[0] = -1;
        }

        if (current_flee_state == 0) {
          theta = 0; // convert 0 to 10 degrees to radians
        }
        if (current_flee_state == 1) {
          theta = 8 * Math.PI / 180;
        }
        if (current_flee_state == -1) {
          theta = -8 * Math.PI / 180;
        }

        if (r == 0) {
          scale = 0.6;
          transform = [scale * current_direction * Math.cos(theta), Math.sin(theta), 0, 0,
          -Math.sin(theta), scale * current_direction * Math.cos(theta), 0, 0,
          0, 0, scale * current_direction * 1, 0,
          mouse_x_pos, mouse_y_pos, 0, 1]
        }

        else {
          if (current_offset[0] < -1) {
            current_offset[0] = 1
          }
          if (current_offset[0] > 1) {
            current_offset[0] = -1
          }
          if (current_offset[1] < -1) {
            current_offset[1] = 1
          }
          if (current_offset[1] > 1) {
            current_offset[1] = -1
          }
          transform = [current_scale * Math.cos(theta), Math.sin(theta), 0, 0,
          -Math.sin(theta), current_scale * Math.cos(theta), 0, 0,
          0, 0, current_scale * 1, 0,
          current_offset[0], current_offset[1], current_offset[2], 1];
        }

        //
        // CONNECT SHADER WITH GEOMETRY
        //
        
        gl.bindBuffer( gl.ARRAY_BUFFER, current_v_buffer );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, current_i_buffer );

        // find the attribute in the shader source
        var a_position = gl.getAttribLocation( shaderprogram, 'a_position' );

        gl.vertexAttribPointer( a_position, 3, gl.FLOAT, false, 0, 0 );

        gl.enableVertexAttribArray ( a_position );

        // find the uniform in the shader source

        var u_transform = gl.getUniformLocation( shaderprogram, 'u_transform');
        // Used ChatGPT to point out the error resulting from variable mix up
        gl.uniformMatrix4fv(u_transform, false, new Float32Array(transform));

        var u_color = gl.getUniformLocation( shaderprogram, 'u_color' );
        
        t = performance.now() * 0.001;
        a = 0.6 + 0.4 * Math.sin(t * 2.0);
        current_color = new Float32Array([
          0.3 + 0.2 * Math.sin(t + 0.0),
          0.6 + 0.2 * Math.sin(t + 2.0),
          0.9 + 0.1 * Math.sin(t + 4.0),
          a
        ]);

        if (r == 0) {
          current_color = [1, 0, 0, 0.8]
        }

        gl.uniform4fv( u_color, current_color );

        //************************************************************//
        //
        // DRAW!
        gl.drawElements( gl.TRIANGLES, 15, gl.UNSIGNED_BYTE, 0);

        gl.uniform4fv(u_color, new Float32Array([0, 0, 0, 0.5]));

        u_pointsize = gl.getUniformLocation(shaderprogram, 'u_pointsize');

        gl.uniform1fv(u_pointsize, new Float32Array([current_scale * 20.]));

        gl.enableVertexAttribArray(a_position);

        gl.bindBuffer(gl.ARRAY_BUFFER, 
        current_eye_v_buffer);

        gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(a_position);
        
        gl.drawArrays(gl.POINTS, 0, 1);

      }


    };

  </script>
  <body>
    <canvas id="c"></canvas>
  </body>
</html>
